# Copyright 2025 RustFS Team
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

---
# Secret containing RustFS admin credentials
apiVersion: v1
kind: Secret
metadata:
  name: rustfs-credentials
  namespace: default
type: Opaque
stringData:
  # RustFS admin access key (username)
  # ‚ö†Ô∏è  IMPORTANT: Change these default values for production deployments!
  # REQUIRED: Must be at least 8 characters long
  accesskey: "rustfsadmin123"

  # RustFS admin secret key (password)
  # REQUIRED: Must be at least 8 characters long
  # Recommendation: Use at least 16 characters with mixed case, numbers, and symbols
  secretkey: "rustfsadmin123"

---
# Tenant using Secret-based credentials (RECOMMENDED for production)
apiVersion: rustfs.com/v1alpha1
kind: Tenant
metadata:
  name: secure-tenant
  namespace: default
spec:
  # RustFS container image
  image: rustfs/rustfs:latest

  # ‚úÖ RECOMMENDED: Reference Secret containing credentials (OPTIONAL)
  # The Secret must contain 'accesskey' and 'secretkey' keys
  # If omitted:
  #   - You can provide credentials via environment variables, OR
  #   - RustFS will use built-in defaults (rustfsadmin/rustfsadmin)
  # Priority: Secret > Environment Variables > RustFS Defaults
  credsSecret:
    name: rustfs-credentials

  # Storage pools configuration
  # In this example, we use a single pool with 2 servers
  pools:
    - name: pool-0
      servers: 2

      persistence:
        volumesPerServer: 2

        # PersistentVolumeClaim template
        # IMPORTANT: Adjust storage class and size for your environment
        volumeClaimTemplate:
          accessModes: ["ReadWriteOnce"]
          resources:
            requests:
              storage: 10Gi
          # Optional: Specify storage class
          # storageClassName: fast-ssd

---
# Alternative: Using environment variables with secretKeyRef (also secure)
# This approach is functionally equivalent but more verbose
#apiVersion: rustfs.com/v1alpha1
#kind: Tenant
#metadata:
#  name: secure-tenant-alt
#  namespace: default
#spec:
#  image: rustfs/rustfs:latest
#
#  # Reference Secret via environment variables
#  # Note: When using this approach, you must manually specify RUSTFS_ACCESS_KEY
#  # and RUSTFS_SECRET_KEY. The 'configuration' approach is simpler.
#  env:
#    - name: RUSTFS_ACCESS_KEY
#      valueFrom:
#        secretKeyRef:
#          name: rustfs-credentials
#          key: accesskey
#    - name: RUSTFS_SECRET_KEY
#      valueFrom:
#        secretKeyRef:
#          name: rustfs-credentials
#          key: secretkey
#
#  pools:
#    - name: pool-0
#      servers: 2
#      persistence:
#        volumesPerServer: 2
#        volumeClaimTemplate:
#          accessModes: ["ReadWriteOnce"]
#          resources:
#            requests:
#              storage: 10Gi

---
# ============================================================================
# DEPLOYMENT INSTRUCTIONS
# ============================================================================

# 1. Create the Secret and Tenant:
#    kubectl apply -f examples/secret-credentials-tenant.yaml

# 2. Verify Secret created:
#    kubectl get secret rustfs-credentials -o yaml

# 3. Verify Tenant created:
#    kubectl get tenant secure-tenant

# 4. Watch Tenant reconciliation:
#    kubectl get tenant secure-tenant -w

# 5. Verify StatefulSet has credential environment variables:
#    kubectl get statefulset secure-tenant-pool-0 -o yaml | grep -A10 "env:"

# 6. Check pod environment (credentials should be referenced, not visible):
#    kubectl describe pod secure-tenant-pool-0-0

# 7. Test S3 API access using the credentials:
#    kubectl port-forward svc/secure-tenant 9000:9000 &
#    aws configure set aws_access_key_id rustfsadmin
#    aws configure set aws_secret_access_key rustfsadmin123
#    aws --endpoint-url http://localhost:9000 s3 ls

# 8. Access RustFS Console UI:
#    kubectl port-forward svc/secure-tenant-console 9001:9001
#    # Open browser: http://localhost:9001
#    # Login with accesskey/secretkey from Secret

# ============================================================================
# PRODUCTION BEST PRACTICES
# ============================================================================

# üîí Security Recommendations:
#
# 1. Generate strong credentials:
#    ACCESSKEY=$(openssl rand -hex 16)
#    SECRETKEY=$(openssl rand -hex 32)
#    kubectl create secret generic rustfs-credentials \
#      --from-literal=accesskey=$ACCESSKEY \
#      --from-literal=secretkey=$SECRETKEY
#
# 2. Use external secret managers (recommended):
#    - External Secrets Operator (ESO)
#    - Sealed Secrets
#    - HashiCorp Vault
#    - AWS Secrets Manager
#    - Azure Key Vault
#
# 3. Enable Kubernetes Secret encryption at rest:
#    - Configure EncryptionConfiguration in kube-apiserver
#    - Use KMS providers (AWS KMS, GCP KMS, Azure Key Vault)
#
# 4. Implement RBAC for Secret access:
#    - Limit who can read/modify the credentials Secret
#    - Use separate namespaces for production workloads
#
# 5. Rotate credentials regularly:
#    - Update Secret data
#    - Restart pods to pick up new credentials
#    - Automate rotation using tools like cert-manager or Vault
#
# 6. Never commit Secrets to version control:
#    - Use GitOps-friendly approaches like Sealed Secrets
#    - Store only references, not actual credentials

# ============================================================================
# TROUBLESHOOTING
# ============================================================================

# Issue: Tenant stuck in reconciliation
# Solution: Check events and logs
#    kubectl describe tenant secure-tenant
#    kubectl get events --field-selector involvedObject.name=secure-tenant
#    kubectl logs deployment/operator-controller-manager

# Issue: Secret not found error
# Solution: Verify Secret exists in same namespace as Tenant
#    kubectl get secret rustfs-credentials -n <namespace>
# Note: The operator will retry every 60 seconds until the Secret is created

# Issue: Missing required keys in Secret
# Solution: Verify Secret contains 'accesskey' and 'secretkey'
#    kubectl get secret rustfs-credentials -o jsonpath='{.data}'
# Note: The operator will retry every 60 seconds until keys are present

# Issue: Credential validation error - keys too short
# Solution: Ensure both accesskey and secretkey are at least 8 characters
#    kubectl get secret rustfs-credentials -o jsonpath='{.data.accesskey}' | base64 -d | wc -c
#    kubectl get secret rustfs-credentials -o jsonpath='{.data.secretkey}' | base64 -d | wc -c
# Note: The operator will retry every 60 seconds until credentials meet requirements

# Issue: Credentials not working
# Solution: Check if credentials match between Secret and RustFS
#    kubectl get secret rustfs-credentials -o jsonpath='{.data.accesskey}' | base64 -d
#    kubectl exec secure-tenant-pool-0-0 -- env | grep RUSTFS_ACCESS_KEY

# Issue: Want to update credentials
# Solution: Update Secret and restart pods
#    kubectl create secret generic rustfs-credentials \
#      --from-literal=accesskey=newkey \
#      --from-literal=secretkey=newsecret \
#      --dry-run=client -o yaml | kubectl apply -f -
#    kubectl rollout restart statefulset secure-tenant-pool-0

# ============================================================================
# ERROR RETRY BEHAVIOR (when Secret is configured)
# ============================================================================

# NOTE: Credential validation only occurs when 'spec.credsSecret' is set.
# If no Secret is configured, the operator skips validation and proceeds with
# reconciliation. If no credentials are provided via environment variables either,
# RustFS will use its built-in defaults (rustfsadmin/rustfsadmin).
# This is acceptable for development but should be changed for production.
#
# The operator uses intelligent retry intervals based on error type:
#
# Credential validation errors (require user action):
#   - Secret not found
#   - Missing required keys (accesskey/secretkey)
#   - Invalid UTF-8 encoding
#   - Credentials too short (less than 8 characters)
#   Retry interval: 60 seconds (reduces log/event spam while you fix the issue)
#
# Transient errors (may self-resolve):
#   - Kubernetes API errors
#   - Network issues
#   Retry interval: 5 seconds (fast recovery when API recovers)
#
# Other validation errors:
#   Retry interval: 15 seconds
#
# Behavior (when Secret is configured):
#   ‚úÖ Auto-recovers when you fix the Secret
#   ‚úÖ Records Warning events on the Tenant
#   ‚úÖ Logs detailed error messages
#   ‚ùå No resources created until Secret is valid
#
# Behavior (when NO Secret is configured):
#   ‚úÖ Resources created immediately (no validation)
#   ‚úÖ RustFS uses defaults if no env vars provided
#
# Example: If you create a Tenant before creating the Secret:
#   1. Operator tries to reconcile, validation fails
#   2. Warning event: "CredentialValidationFailed: Secret 'rustfs-credentials' not found"
#   3. Waits 60 seconds, retries
#   4. You create the Secret
#   5. Next retry succeeds, resources created!
